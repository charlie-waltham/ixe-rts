$CREEPER_CHUNK_SIZE:8
$FRONTLINE_SIZE:8
$BEACON_RANGE:32

if (GetPause) return endif
ElapsedTime >start
@FindFrontlines
ElapsedTime <start - <time + >time

return
if (GetGameUpdateCount 30 % eq0)
    <avgTime <time + >avgTime
    <avgCount 1 + >avgCount

    PrintAllSp("Time:" <time "ms<br>Avg:" <avgTime <avgCount / "ms")
    0 >time
endif

:Once
    <CREEPER_CHUNK_SIZE ->*CREEPER_CHUNK_SIZE
    <CREEPER_CHUNK_SIZE dup * 2 / >maxSandInChunk
    <BEACON_RANGE dup * >sqrBeaconRange
    512 <CREEPER_CHUNK_SIZE / >numChunks
    0 >currentRow
    V2(-1 -1) >nullVector
    <FRONTLINE_SIZE 0 do CreateList loop List ->*frontlineCells
    false >debugFrontline

    0 >time
    0 >avgTime
    0 >avgCount

    256 0 do
        if (GetSandDefData(i){"blocksUnits"}) i endif
    loop
    List 11 20 >blockingSands

    GetUnitsByName("/rts/dummy") >dummies
    <dummies 0 do Destroy(<dummies[i] false) loop

    <FRONTLINE_SIZE <CREEPER_CHUNK_SIZE * >losRange
    <numChunks 0 do
        V2(0 i <CREEPER_CHUNK_SIZE *) <CREEPER_CHUNK_SIZE 2 / + >unitPos
        CreateUnit("/rts/dummy" <unitPos true) >unit
        SetLosRange(<unit <losRange)
        EnableLos(<unit true)
        <unit
    loop
    List >losUnits

    RegisterForMsg("DebugFrontline" dup)
    
    @GameLoaded

:GameLoaded
    RegisterScript("frontline")

:FindFrontlines
    # Delete any previous frontline cells from this row
    <-*frontlineCells 0 do
        # Iterate through cells in reverse order to allow removing elements without index shifting
        -1 <-*frontlineCells[i] 1 - do
            <-*frontlineCells[j][i] >currentCell
            if (<currentCell.x <currentRow <CREEPER_CHUNK_SIZE * ==)
                RemoveListElement(<-*frontlineCells[j] i)
            endif
        loop
    loop

    GetUnitsByName("/rts/units/beacon/beacon") >beacons
    <beacons 0 do
        if (ReadConfig(<beacons[i] "beaconEnable"))
            GetPosition(<beacons[i])
        endif
    loop
    List >beaconPositions

    <numChunks 0 do
        V2(<currentRow i) <CREEPER_CHUNK_SIZE * <CREEPER_CHUNK_SIZE 2 / + >chunkPos

        false >inBeaconRange
        <beaconPositions 0 do
            SqrMagnitude(<chunkPos <beaconPositions[i] -) >sqrMag
            if (SqrMagnitude(<chunkPos <beaconPositions[i] -) <sqrBeaconRange lte)
                true >inBeaconRange
                break
            endif
        loop

        false >los
        if (<inBeaconRange !)
            GetNearestCreeper(<losUnits[i] false) >nearestCreeper
            if (<nearestCreeper <nullVector !=)
                GetLos(<losUnits[i] <nearestCreeper.x <nearestCreeper.y) >los
            else
                false >los
            endif
            # Update position of los dummy now as position takes a frame to update
            SetPosition(<losUnits[i] <chunkPos V2(<CREEPER_CHUNK_SIZE 0) +)
        endif

        if (<los <inBeaconRange ||)
            # Gets the area of the chunk, equal to (x, y) * chunkSize, (x,y) * chunkSize + chunkSize
            V4(
                <currentRow <CREEPER_CHUNK_SIZE * i <CREEPER_CHUNK_SIZE *
                dup2 <CREEPER_CHUNK_SIZE + swap <CREEPER_CHUNK_SIZE + swap
            ) >area
            
            # Check if this cell is a valid frontline, and return a value for its distance from the creeper
            0 >distance
            if (GetSandInArea(<area false <blockingSands true) GetListCount <maxSandInChunk lt # Cell <50% sand
                GetCreeperInArea(<area false false) eq0 &&) # Creeper in cell is 0

                # Set distance to 1 if in range of beacon
                if (<inBeaconRange)
                    1 >distance
                else
                    # IRPL execution is slow enough that sqrt is faster than creating a lookup table / array
                    Magnitude(<chunkPos <nearestCreeper - <CREEPER_CHUNK_SIZE /) asint 1 + >distance
                endif
            endif

            if (<distance neq0)
                # frontlineCells has a list for each cell distance.
                # This is so units can be prioritised to be close to the creeper.
                AppendToList(<-*frontlineCells[<distance 1 -] V2(<area.x <area.y))

                if (<debugFrontline)
                    <sprites[i][<currentRow] >sprite
                    <distance 1 - <FRONTLINE_SIZE asfloat / >colour
                    SetSpriteColor(<sprite V4(0 <colour 1 <colour - 0.8))
                    SetSpriteActive(<sprite true)
                endif
            else
                if (<debugFrontline)
                    SetSpriteActive(<sprites[i][<currentRow] false)
                endif
            endif
        else
            if (<debugFrontline)
                SetSpriteActive(<sprites[i][<currentRow] false)
            endif
        endif
    loop

    # Increment row or loop back to 0
    <currentRow 1 + <numChunks mod >currentRow

:DebugSprite
    # @DebugSprite(<image <origin <position <scale <color) >sprite

    >color >scale >position >origin >image
    CreateSprite(<image <origin) >sprite
    SetSpriteScale(<sprite <scale)
    SetSpriteColor(<sprite <color)
    SetSpritePosition(<sprite <position false)
    <sprite

:DebugFrontline
    <_DATA{"data"}{"frontlineToggle"} >debugFrontline

    if (<debugFrontline)
        <numChunks 0 do
            <numChunks 0 do
                @DebugSprite("/rts/images/square.png" 
                    Vector0
                    V2(i <CREEPER_CHUNK_SIZE * j <CREEPER_CHUNK_SIZE *)
                    V2(<CREEPER_CHUNK_SIZE 2 * dup)
                    Vector0
                )
                dup false SetSpriteActive
            loop
            <numChunks ListN
        loop
        List >sprites
    else
        <sprites 0 do
            <sprites[i] 0 do
                DestroySprite(<sprites[i][j])
            loop
        loop

        --sprites
    endif