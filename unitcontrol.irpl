$MAX_DELAY:10
$ATTEMPTS_PER_DIST:3
$FIND_UNASSIGNED_ATTEMPTS:10
$FIND_ANY_ATTEMPTS:10
$MOVES_BEFORE_FORCE:30
$FAILED_MOVES_BEFORE_FORCE:5
$RESET_DURATION:120
$UPGRADE_RANGE_THRESHOLD:3

if (<apexFound !)
    if (GetApex -1 !=)
        # Enabling global reachable area seems to be the main performance bottleneck, interestingly
        EnableRa(GetApex true)
        SetRaRange(GetApex 725)
        true >apexFound
    else
        return
    endif
endif

if (GetTimer0 eq0)
    if (GetApex -1 ==) false >apexFound endif

    if (GetUpgradeBoost <UPGRADE_RANGE_THRESHOLD >)
        once
            GetTableKeys(<ugpradedShipData) >keys
            <keys 0 do
                <ugpradedShipData{<keys[i]} >shipData{<keys[i]}
            loop
        endonce
    endif

    @MoveUnits
    SetTimer0(<MAX_DELAY GetListCount(<units) 0.1 * - 1 max)
endif

if (GetTimer1 eq0)
    false >reset
endif

:Once
    # Frontline ships
    "$/defender/defender"               "scale" V2(10 8)  "maxDistance" 3 2 TableN
    "$/gunship/gunship"                 "scale" V2(16 11) "maxDistance" 5 2 TableN
    "$/frigate/frigate"                 "scale" V2(34 14) "maxDistance" 5 2 TableN
    "$/cryon/cryon"                     "scale" V2(16 12) "maxDistance" 3 2 TableN # Not actually controlled for now
    "$/particulateship/particulateship" "scale" V2(12 10) "maxDistance" 3 2 TableN
    "/rts/units/minimaker/minimaker"    "scale" V2(16 14) "maxDistance" 3 2 TableN
    "/rts/units/shield/shield"          "scale" V2(10 10) "maxDistance" 4 2 TableN
    # Uncontrolled ships (PITA!!!!)
    "$/apexship/ship" "scale" V2(44 16) 1 TableN
    "$/apexabraxis/apexabraxis" "scale" V2(44 16) 1 TableN # Not the same as normal apex but close enough
    "/rts/units/apex/apex" "scale" V2(44 20) 1 TableN
    "$/digger/digger" "scale" V2(12 12) 1 TableN
    "$/reactor/reactor" "scale" V2(10, 10) 1 TableN
    "$/duster/duster" "scale" V2(12, 10) 1 TableN
    "$/oreminer/oreminer" "scale" V2(8, 8) 1 TableN
    "$/nullifier/nullifier" "scale" V2(12 12) 1 TableN
    "/rts/units/excavator/excavator" "scale" V2(12 12) 1 TableN
    "$/coilship/coilship" "scale" V2(18 12) 1 TableN
    "$/ixecore/ixecore" "scale" V2(12 12) 1 TableN
    "$/spiritship/spiritship" "scale" V2(32 24) 1 TableN
    "$/portal/portal" "scale" V2(8 8) 1 TableN
    Table >shipData

    # To be used when the amount of collected upgrade gems is above a threshold (increased range)
    "$/defender/defender"               "scale" V2(10 8)  "maxDistance" 5 2 TableN
    "$/gunship/gunship"                 "scale" V2(16 11) "maxDistance" 7 2 TableN
    "$/frigate/frigate"                 "scale" V2(34 14) "maxDistance" 7 2 TableN
    "$/cryon/cryon"                     "scale" V2(16 12) "maxDistance" 5 2 TableN # Not actually controlled for now
    "$/particulateship/particulateship" "scale" V2(12 10) "maxDistance" 5 2 TableN
    "/rts/units/minimaker/minimaker"    "scale" V2(16 14) "maxDistance" 5 2 TableN
    "/rts/units/shield/shield"          "scale" V2(10 10) "maxDistance" 4 2 TableN
    Table >ugpradedShipData

    GetTableKeys(<shipData) >allShips
    "$/defender/defender" "$/gunship/gunship" "$/frigate/frigate" "$/particulateship/particulateship" "/rts/units/minimaker/minimaker" "/rts/units/shield/shield" List >frontlineShips

    RegisterForMsg("ResetShips" dup)
    RegisterForMsg("DebugPlacements" dup)

    256 0 do
        if (GetSandDefData(i){"blocksUnits"}) i endif
    loop
    List >blockingSands

    false >invalidPath
    false >reset
    false >debugPlacements
    true >isUnassigned
    0 >count
    0 >failedMoves
    CreateList >sprites
    @GameLoaded

    SetTimer0(<MAX_DELAY)
    SetTimerObeyPause0(true)
    SetTimerObeyPause1(true)

:GameLoaded
    false >apexFound
    RegisterScript("unitcontrol")

:MoveUnits
    # Don't bother if no frontline cells to move to
    0
    <-*frontlineCells 0 do
        GetListCount(<-*frontlineCells[i]) +
    loop
    eq0 if return endif

    GetUnitsInRange(256 256 512 <frontlineShips) >units
    CreateList >unassignedUnits

    # First try to find a unit in an invalid place
    -1 >unit
    if (<failedMoves <FAILED_MOVES_BEFORE_FORCE <) # Skip this if it failed too many times
        <FIND_UNASSIGNED_ATTEMPTS 0 do
            <units[RandInt(0 <units)] >potentialUnit
            if (@IsUnitUnassigned(<potentialUnit))
                <potentialUnit >unit
                true >isUnassigned
                break
            endif
        loop
    endif

    # Otherwise, move any unit if it's been long enough, reset is enabled or failed finding move positions enough times
    if (<unit -1 ==)
        <count 1 + >count
        if (<count <MOVES_BEFORE_FORCE > <failedMoves <FAILED_MOVES_BEFORE_FORCE >= || <reset ||)
            0 >count
            <FIND_ANY_ATTEMPTS 0 do
                <units[RandInt(0 <units)] >potentialUnit
                if (GetOnBoardComplete(<potentialUnit 0 true))
                    <potentialUnit >unit
                    false >isUnassigned
                    break
                endif
            loop
        endif
    endif

    if (<unit -1 ==) return endif

    <sprites 0 do
        DestroySprite(<sprites[i])
    loop

    GetUnitsInRange(256 256 512 <allShips) >allUnits
    <allUnits 0 do
        <allUnits[i]
        @GetRectVertices(
            GetPosition(<allUnits[i])
            <shipData{GetName(<allUnits[i])}{"scale"}
        )
    loop
    Table >unitRects

    GetName(<unit) >unitName
    <shipData{<unitName} >ship
    <ship{"scale"} 2 / >shipR
    false >locationFound

    <ship{"maxDistance"} 1 + 0 do
        <-*frontlineCells[i] >currentFrontline

        <ATTEMPTS_PER_DIST 0 do
            RandInt(0 GetListCount(<currentFrontline)) >cellId
            RandInt(0 <-*CREEPER_CHUNK_SIZE) RandInt(0 <-*CREEPER_CHUNK_SIZE) V2 >innerPos
            <currentFrontline[<cellId] <innerPos + >newPos

            if (@IsValidPosition(<newPos <ship <unit))
                MoveUnit(<unit <newPos)
                true >locationFound
                break
            endif

            if (<debugPlacements)
                @GetRectVertices(<newPos <ship{"scale"}) >rect
                @DebugSprite("/rts/images/square.png"
                    Vector0
                    <rect
                    <ship{"scale"} 2 *
                    V4(1 0 0 0.5)
                ) >sprite
                AppendToList(<sprites <sprite)
            endif
        loop

        if (<locationFound)
            break
        endif
    loop

    if (<locationFound)
        0 >failedMoves
    else if (<isUnassigned)
        <failedMoves 1 + >failedMoves
    endif endif

:IsUnitUnassigned
    # @IsUnitUnassigned(<unit) >isUnassigned
    >thisUnit

    GetPosition(<thisUnit) >pos

    #GetRaPath(GetApex <pos) >path
    #<path 0 do
    #    <path[i] >pathPos
    #    if (GetCreeper(<pathPos.x <pathPos.y) gt0)
    #        false return
    #    endif
    #loop

    if (GetCreeper(<pos.x <pos.y) gt0) true return endif

    <shipData{GetName(<thisUnit)} >ship
    V2 (
        <pos.x dup <-*CREEPER_CHUNK_SIZE mod -
        <pos.y dup <-*CREEPER_CHUNK_SIZE mod -
    ) >currentCell

    <ship{"maxDistance"} 1 + 0 do
        if (ListContains(<-*frontlineCells[i] <currentCell))
            false return
        endif
    loop

    true

:IsValidPosition
    # @IsValidPosition(<pos <ship <unit) >isValid
    >unit >ship >pos

    # Is valid path to apex
    GetRaPath(GetApex <pos) >path
    if (GetListCount(<path) eq0) false return endif

    # Alternative to RA system, but has worse performance when needed (16ms vs 1ms)
    #if (IsPassable(GetPosition(GetApex) <pos V4(0 0 512 512) false) !) false return endif

    # Path does not intersect with creeper
    <path 0 do
        <path[i] >pathPos
        if (GetCreeper(<pathPos.x <pathPos.y) gt0)
            false return
        endif
    loop

    @GetRectVertices(<pos <ship{"scale"}) >newRect

    # Unit in map bounds
    if (
        <newRect.0 lt0
        <newRect.1 lt0 ||
        <newRect.2 512 > ||
        <newRect.3 512 > ||
    )
        false return
    endif

    # Not overlapping with other units
    <allUnits 0 do
        if (<unit <allUnits[i] !=)
            if (@IsOverlapping(<newRect <unitRects{<allUnits[i]}))
                false return
            endif
        endif
    loop

    # Area is clear of blocking sands
    GetSandInArea(<newRect false <blockingSands true) GetListCount >sandCount
    if (<sandCount neq0) false return endif

    true return

:IsOverlapping
    # @IsOverlapping(<rect1 <rect2) >isOverlapping
    >rect2 >rect1

    <rect1.2 <rect2.0 <
    <rect1.0 <rect2.2 > ||
    <rect1.3 <rect2.1 < ||
    <rect1.1 <rect2.3 > || !

:GetRectVertices
    # @GetRectVertices(<centrePos <scale) >vertices
    >rectScale >rectPos

    <rectScale 2 / >rect2
    V4(
        <rectPos <rect2 - EV2
        <rectPos <rect2 + EV2
    )

:DebugSprite
    # @DebugSprite(<image <origin <position <scale <color) >sprite
    >color >scale >position >origin >image
    
    CreateSprite(<image <origin) >sprite
    SetSpriteScale(<sprite <scale)
    SetSpriteColor(<sprite <color)
    SetSpritePosition(<sprite <position false)

:ResetShips
    true >reset
    SetTimer1(<RESET_DURATION)

:DebugPlacements
    <_DATA{"data"}{"placementToggle"} >debugPlacements